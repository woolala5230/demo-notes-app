export class DataApiDriver {
    #config;
    constructor(config) {
        this.#config = config;
    }
    async init() { }
    async acquireConnection() {
        return new DataApiConnection(this.#config);
    }
    async beginTransaction(conn) {
        await conn.beginTransaction();
    }
    async commitTransaction(conn) {
        await conn.commitTransaction();
    }
    async rollbackTransaction(conn) {
        await conn.rollbackTransaction();
    }
    async releaseConnection(_connection) { }
    async destroy() { }
}
class DataApiConnection {
    #config;
    #transactionId;
    constructor(config) {
        this.#config = config;
    }
    async beginTransaction() {
        const r = await this.#config.client
            .beginTransaction({
            secretArn: this.#config.secretArn,
            resourceArn: this.#config.resourceArn,
            database: this.#config.database,
        })
            .promise();
        this.#transactionId = r.transactionId;
    }
    async commitTransaction() {
        if (!this.#transactionId)
            throw new Error("Cannot commit a transaction before creating it");
        await this.#config.client
            .commitTransaction({
            secretArn: this.#config.secretArn,
            resourceArn: this.#config.resourceArn,
            transactionId: this.#transactionId,
        })
            .promise();
    }
    async rollbackTransaction() {
        if (!this.#transactionId)
            throw new Error("Cannot rollback a transaction before creating it");
        await this.#config.client
            .rollbackTransaction({
            secretArn: this.#config.secretArn,
            resourceArn: this.#config.resourceArn,
            transactionId: this.#transactionId,
        })
            .promise();
    }
    async executeQuery(compiledQuery) {
        const r = await this.#config.client
            .executeStatement({
            transactionId: this.#transactionId,
            secretArn: this.#config.secretArn,
            resourceArn: this.#config.resourceArn,
            sql: compiledQuery.sql,
            parameters: compiledQuery.parameters,
            database: this.#config.database,
            includeResultMetadata: true,
        })
            .promise();
        if (!r.columnMetadata) {
            return {
                numUpdatedOrDeletedRows: BigInt(r.numberOfRecordsUpdated || 0),
                rows: [],
            };
        }
        const rows = r.records
            ?.filter((r) => r.length !== 0)
            .map((rec) => Object.fromEntries(rec.map((val, i) => [
            r.columnMetadata[i].name,
            val.stringValue ??
                val.blobValue ??
                val.longValue ??
                val.arrayValue ??
                val.doubleValue ??
                (val.isNull ? null : val.booleanValue),
        ])));
        const result = {
            rows: rows || [],
        };
        return result;
    }
}
